// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/storage.proto

package almanac

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ChunkId_Type int32

const (
	// Enum sentinel to make sure that the value is always set explicitly.
	ChunkId_UNKNOWN_TYPE ChunkId_Type = 0
	// Small chunks hold few entries and have a small spread.
	ChunkId_SMALL ChunkId_Type = 1
	// Big chunks hold many entries and have a large spread.
	ChunkId_BIG ChunkId_Type = 2
)

var ChunkId_Type_name = map[int32]string{
	0: "UNKNOWN_TYPE",
	1: "SMALL",
	2: "BIG",
}
var ChunkId_Type_value = map[string]int32{
	"UNKNOWN_TYPE": 0,
	"SMALL":        1,
	"BIG":          2,
}

func (x ChunkId_Type) String() string {
	return proto.EnumName(ChunkId_Type_name, int32(x))
}
func (ChunkId_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{2, 0} }

// A log entry.
type LogEntry struct {
	// The json representation of the entry as supplied by the user.
	EntryJson string `protobuf:"bytes,1,opt,name=entry_json,json=entryJson" json:"entry_json,omitempty"`
	// An epoch timestamp in milliseconds associated with this entry.
	TimestampMs int64 `protobuf:"varint,2,opt,name=timestamp_ms,json=timestampMs" json:"timestamp_ms,omitempty"`
	// A globally unique id for this log entry.
	Id string `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
}

func (m *LogEntry) Reset()                    { *m = LogEntry{} }
func (m *LogEntry) String() string            { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()               {}
func (*LogEntry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *LogEntry) GetEntryJson() string {
	if m != nil {
		return m.EntryJson
	}
	return ""
}

func (m *LogEntry) GetTimestampMs() int64 {
	if m != nil {
		return m.TimestampMs
	}
	return 0
}

func (m *LogEntry) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type BleveIndex struct {
	// Holds the bytes corresponding to a zip archive containing the entire
	// directory tree as used by Bleve.
	DirectoryZip []byte `protobuf:"bytes,1,opt,name=directory_zip,json=directoryZip,proto3" json:"directory_zip,omitempty"`
}

func (m *BleveIndex) Reset()                    { *m = BleveIndex{} }
func (m *BleveIndex) String() string            { return proto.CompactTextString(m) }
func (*BleveIndex) ProtoMessage()               {}
func (*BleveIndex) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *BleveIndex) GetDirectoryZip() []byte {
	if m != nil {
		return m.DirectoryZip
	}
	return nil
}

// Holds the data used to identify a chunk.
type ChunkId struct {
	// The smallest timestamp of any entry present in the chunk.
	StartMs int64 `protobuf:"varint,1,opt,name=start_ms,json=startMs" json:"start_ms,omitempty"`
	// The greatest timestamp of any entry present in the chunk.
	EndMs int64 `protobuf:"varint,2,opt,name=end_ms,json=endMs" json:"end_ms,omitempty"`
	// A unique id used to avoid chunk id collisions for chunks produced on
	// different machines.
	Uid string `protobuf:"bytes,3,opt,name=uid" json:"uid,omitempty"`
	// Must be set to something other than "UNKNOWN_TYPE".
	Type ChunkId_Type `protobuf:"varint,4,opt,name=type,enum=almanac.ChunkId_Type" json:"type,omitempty"`
}

func (m *ChunkId) Reset()                    { *m = ChunkId{} }
func (m *ChunkId) String() string            { return proto.CompactTextString(m) }
func (*ChunkId) ProtoMessage()               {}
func (*ChunkId) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *ChunkId) GetStartMs() int64 {
	if m != nil {
		return m.StartMs
	}
	return 0
}

func (m *ChunkId) GetEndMs() int64 {
	if m != nil {
		return m.EndMs
	}
	return 0
}

func (m *ChunkId) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ChunkId) GetType() ChunkId_Type {
	if m != nil {
		return m.Type
	}
	return ChunkId_UNKNOWN_TYPE
}

// Represents a chunk of log entries and some additional information about the
// entries.
type Chunk struct {
	// The identifier of this chunk. Used to determine its name in canonical
	// storage.
	Id *ChunkId `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The raw entries present in this chunk.
	Entries []*LogEntry `protobuf:"bytes,2,rep,name=entries" json:"entries,omitempty"`
	// An serialized index which can be used to perform searches.
	Index *BleveIndex `protobuf:"bytes,3,opt,name=index" json:"index,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (m *Chunk) String() string            { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *Chunk) GetId() *ChunkId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Chunk) GetEntries() []*LogEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *Chunk) GetIndex() *BleveIndex {
	if m != nil {
		return m.Index
	}
	return nil
}

func init() {
	proto.RegisterType((*LogEntry)(nil), "almanac.LogEntry")
	proto.RegisterType((*BleveIndex)(nil), "almanac.BleveIndex")
	proto.RegisterType((*ChunkId)(nil), "almanac.ChunkId")
	proto.RegisterType((*Chunk)(nil), "almanac.Chunk")
	proto.RegisterEnum("almanac.ChunkId_Type", ChunkId_Type_name, ChunkId_Type_value)
}

func init() { proto.RegisterFile("proto/storage.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 352 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x51, 0x6f, 0x6b, 0x9b, 0x40,
	0x1c, 0xde, 0x69, 0x8c, 0xc9, 0x4f, 0x17, 0xdc, 0x85, 0x80, 0x7b, 0x31, 0x70, 0xee, 0x8d, 0x61,
	0xc3, 0x31, 0xf7, 0x09, 0x96, 0x11, 0x4a, 0xda, 0x98, 0x16, 0x9b, 0x52, 0x5a, 0x0a, 0x62, 0xe3,
	0x91, 0x5e, 0x1b, 0x4f, 0xf1, 0x2e, 0xa5, 0xf6, 0x5d, 0xbf, 0x4c, 0x3f, 0x67, 0xb9, 0x6b, 0x62,
	0xa0, 0xef, 0x7e, 0xcf, 0xc3, 0xa3, 0xcf, 0x9f, 0x83, 0x61, 0x55, 0x97, 0xa2, 0xfc, 0xcd, 0x45,
	0x59, 0x67, 0x6b, 0x12, 0x2a, 0x84, 0xcd, 0x6c, 0x53, 0x64, 0x2c, 0x5b, 0xf9, 0x37, 0xd0, 0x9b,
	0x97, 0xeb, 0x29, 0x13, 0x75, 0x83, 0xbf, 0x01, 0x10, 0x79, 0xa4, 0xf7, 0xbc, 0x64, 0x2e, 0xf2,
	0x50, 0xd0, 0x4f, 0xfa, 0x8a, 0x39, 0xe6, 0x25, 0xc3, 0xdf, 0xc1, 0x16, 0xb4, 0x20, 0x5c, 0x64,
	0x45, 0x95, 0x16, 0xdc, 0xd5, 0x3c, 0x14, 0xe8, 0x89, 0xd5, 0x72, 0x31, 0xc7, 0x03, 0xd0, 0x68,
	0xee, 0xea, 0xea, 0x4b, 0x8d, 0xe6, 0xfe, 0x1f, 0x80, 0xc9, 0x86, 0x3c, 0x92, 0x19, 0xcb, 0xc9,
	0x13, 0xfe, 0x01, 0x9f, 0x73, 0x5a, 0x93, 0x95, 0x28, 0xeb, 0x26, 0x7d, 0xa6, 0x95, 0xb2, 0xb0,
	0x13, 0xbb, 0x25, 0xaf, 0x69, 0xe5, 0xbf, 0x22, 0x30, 0xff, 0xdf, 0x6d, 0xd9, 0xc3, 0x2c, 0xc7,
	0x5f, 0xa1, 0xc7, 0x45, 0x56, 0x0b, 0xe9, 0x86, 0x94, 0x9b, 0xa9, 0x70, 0xcc, 0xf1, 0x08, 0xba,
	0x84, 0xe5, 0x87, 0x18, 0x06, 0x61, 0x79, 0xcc, 0xb1, 0x03, 0xfa, 0xb6, 0x4d, 0x20, 0x4f, 0x3c,
	0x86, 0x8e, 0x68, 0x2a, 0xe2, 0x76, 0x3c, 0x14, 0x0c, 0xa2, 0x51, 0xb8, 0x2b, 0x1e, 0xee, 0x3c,
	0xc2, 0x65, 0x53, 0x91, 0x44, 0x49, 0xfc, 0x5f, 0xd0, 0x91, 0x08, 0x3b, 0x60, 0x5f, 0x2c, 0x4e,
	0x16, 0xa7, 0x97, 0x8b, 0x74, 0x79, 0x75, 0x36, 0x75, 0x3e, 0xe1, 0x3e, 0x18, 0xe7, 0xf1, 0xbf,
	0xf9, 0xdc, 0x41, 0xd8, 0x04, 0x7d, 0x32, 0x3b, 0x72, 0x34, 0xff, 0x05, 0x81, 0xa1, 0x7e, 0x82,
	0x3d, 0xd5, 0x5a, 0x06, 0xb4, 0x22, 0xe7, 0xa3, 0x81, 0xdc, 0x01, 0xff, 0x04, 0x53, 0xee, 0x48,
	0x89, 0x8c, 0xab, 0x07, 0x56, 0xf4, 0xa5, 0x95, 0xed, 0xd7, 0x4f, 0xf6, 0x0a, 0x3c, 0x06, 0x83,
	0xca, 0xbd, 0x54, 0x0b, 0x2b, 0x1a, 0xb6, 0xd2, 0xc3, 0x94, 0xc9, 0xbb, 0xe2, 0xb6, 0xab, 0x5e,
	0xf3, 0xef, 0x5b, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc6, 0x88, 0x6f, 0x91, 0xe4, 0x01, 0x00, 0x00,
}
