// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/storage.proto

package almanac

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// A log entry.
type LogEntry struct {
	// The json representation of the entry as supplied by the user.
	EntryJson string `protobuf:"bytes,1,opt,name=entry_json,json=entryJson" json:"entry_json,omitempty"`
	// An epoch timestamp in milliseconds associated with this entry.
	TimestampMs int64 `protobuf:"varint,2,opt,name=timestamp_ms,json=timestampMs" json:"timestamp_ms,omitempty"`
	// A globally unique id for this log entry.
	Id string `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
}

func (m *LogEntry) Reset()                    { *m = LogEntry{} }
func (m *LogEntry) String() string            { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()               {}
func (*LogEntry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *LogEntry) GetEntryJson() string {
	if m != nil {
		return m.EntryJson
	}
	return ""
}

func (m *LogEntry) GetTimestampMs() int64 {
	if m != nil {
		return m.TimestampMs
	}
	return 0
}

func (m *LogEntry) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type BleveIndex struct {
	// Holds the bytes corresponding to a zip archive containing the entire
	// directory tree as used by Bleve.
	DirectoryZip []byte `protobuf:"bytes,1,opt,name=directory_zip,json=directoryZip,proto3" json:"directory_zip,omitempty"`
}

func (m *BleveIndex) Reset()                    { *m = BleveIndex{} }
func (m *BleveIndex) String() string            { return proto.CompactTextString(m) }
func (*BleveIndex) ProtoMessage()               {}
func (*BleveIndex) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *BleveIndex) GetDirectoryZip() []byte {
	if m != nil {
		return m.DirectoryZip
	}
	return nil
}

// Holds the data used to identify a chunk.
type ChunkId struct {
	// The smallest timestamp of any entry present in the chunk.
	StartMs int64 `protobuf:"varint,1,opt,name=start_ms,json=startMs" json:"start_ms,omitempty"`
	// The greatest timestamp of any entry present in the chunk.
	EndMs int64 `protobuf:"varint,2,opt,name=end_ms,json=endMs" json:"end_ms,omitempty"`
	// A unique id used to avoid chunk id collisions for chunks produced on
	// different machines.
	Uid string `protobuf:"bytes,3,opt,name=uid" json:"uid,omitempty"`
}

func (m *ChunkId) Reset()                    { *m = ChunkId{} }
func (m *ChunkId) String() string            { return proto.CompactTextString(m) }
func (*ChunkId) ProtoMessage()               {}
func (*ChunkId) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *ChunkId) GetStartMs() int64 {
	if m != nil {
		return m.StartMs
	}
	return 0
}

func (m *ChunkId) GetEndMs() int64 {
	if m != nil {
		return m.EndMs
	}
	return 0
}

func (m *ChunkId) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

// Represents a chunk of log entries and some additional information about the
// entries.
type Chunk struct {
	// The identifier of this chunk. Used to determine its name in canonical
	// storage.
	Id *ChunkId `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// The raw entries present in this chunk.
	Entries []*LogEntry `protobuf:"bytes,2,rep,name=entries" json:"entries,omitempty"`
	// An serialized index which can be used to perform searches.
	Index *BleveIndex `protobuf:"bytes,3,opt,name=index" json:"index,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (m *Chunk) String() string            { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *Chunk) GetId() *ChunkId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Chunk) GetEntries() []*LogEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *Chunk) GetIndex() *BleveIndex {
	if m != nil {
		return m.Index
	}
	return nil
}

func init() {
	proto.RegisterType((*LogEntry)(nil), "almanac.LogEntry")
	proto.RegisterType((*BleveIndex)(nil), "almanac.BleveIndex")
	proto.RegisterType((*ChunkId)(nil), "almanac.ChunkId")
	proto.RegisterType((*Chunk)(nil), "almanac.Chunk")
}

func init() { proto.RegisterFile("proto/storage.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 281 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x44, 0x50, 0xcf, 0x4b, 0xc3, 0x30,
	0x14, 0xa6, 0x2b, 0x5d, 0xb7, 0xd7, 0x2a, 0xf3, 0x0d, 0xa1, 0x1e, 0x84, 0x5a, 0x2f, 0x15, 0xa1,
	0x62, 0xfd, 0x0f, 0x14, 0x0f, 0x13, 0x7b, 0xe9, 0x51, 0x84, 0x12, 0x97, 0x30, 0xa3, 0x6b, 0x52,
	0x92, 0x4c, 0x9c, 0x37, 0xff, 0x73, 0x49, 0xdc, 0xb2, 0xdb, 0x7b, 0x1f, 0xdf, 0xfb, 0x7e, 0x3c,
	0x98, 0x0f, 0x4a, 0x1a, 0x79, 0xa3, 0x8d, 0x54, 0x64, 0xc5, 0x2a, 0xb7, 0x61, 0x4c, 0xd6, 0x3d,
	0x11, 0x64, 0x59, 0xbc, 0xc2, 0xe4, 0x59, 0xae, 0x1e, 0x85, 0x51, 0x5b, 0x3c, 0x07, 0x60, 0x76,
	0xe8, 0x3e, 0xb4, 0x14, 0x59, 0x90, 0x07, 0xe5, 0xb4, 0x9d, 0x3a, 0xe4, 0x49, 0x4b, 0x81, 0x17,
	0x90, 0x1a, 0xde, 0x33, 0x6d, 0x48, 0x3f, 0x74, 0xbd, 0xce, 0x46, 0x79, 0x50, 0x86, 0x6d, 0xe2,
	0xb1, 0x46, 0xe3, 0x31, 0x8c, 0x38, 0xcd, 0x42, 0x77, 0x39, 0xe2, 0xb4, 0xb8, 0x05, 0xb8, 0x5f,
	0xb3, 0x2f, 0xb6, 0x10, 0x94, 0x7d, 0xe3, 0x25, 0x1c, 0x51, 0xae, 0xd8, 0xd2, 0x48, 0xb5, 0xed,
	0x7e, 0xf8, 0xe0, 0x2c, 0xd2, 0x36, 0xf5, 0xe0, 0x0b, 0x1f, 0x8a, 0x06, 0xe2, 0x87, 0xf7, 0x8d,
	0xf8, 0x5c, 0x50, 0x3c, 0x83, 0x89, 0x36, 0x44, 0x19, 0x6b, 0x16, 0x38, 0xb3, 0xd8, 0xed, 0x8d,
	0xc6, 0x53, 0x18, 0x33, 0x41, 0x0f, 0x29, 0x22, 0x26, 0x68, 0xa3, 0x71, 0x06, 0xe1, 0xc6, 0x07,
	0xb0, 0x63, 0xf1, 0x1b, 0x40, 0xe4, 0xf4, 0x30, 0x77, 0xd9, 0xac, 0x4e, 0x52, 0xcf, 0xaa, 0x5d,
	0xff, 0x6a, 0xe7, 0x65, 0xd3, 0xe2, 0x35, 0xc4, 0xb6, 0x2d, 0x67, 0x56, 0x35, 0x2c, 0x93, 0xfa,
	0xc4, 0xd3, 0xf6, 0x3f, 0x6a, 0xf7, 0x0c, 0xbc, 0x82, 0x88, 0xdb, 0x56, 0xce, 0x2c, 0xa9, 0xe7,
	0x9e, 0x7a, 0x28, 0xdc, 0xfe, 0x33, 0xde, 0xc6, 0xee, 0xe7, 0x77, 0x7f, 0x01, 0x00, 0x00, 0xff,
	0xff, 0xf6, 0x65, 0xde, 0x8d, 0x8a, 0x01, 0x00, 0x00,
}
